import { useInterstitial } from '@ads';
import { db, storage } from '@api/config.firebase';
import Icon from '@assets/icons';
import { CustomButton, PhotoPickerModal } from '@components';
import { Seer, useFortuneNotificationManager } from '@hooks';
import { useAuth, useTheme, useToast } from '@providers';
import { Image } from 'expo-image';
import * as ImagePicker from 'expo-image-picker';
import { router, useLocalSearchParams } from 'expo-router';
import { arrayUnion, doc, getDoc, updateDoc } from 'firebase/firestore';
import { getDownloadURL, ref, uploadBytes } from 'firebase/storage';
import { useState } from 'react';
import { ScrollView, Text, TouchableOpacity, View } from 'react-native';
import Animated, { FadeIn, FadeInDown, SlideInRight } from 'react-native-reanimated';
import styles from './styles';

const CoffeeFortune = () => {
  const { seerData } = useLocalSearchParams();
  const seer: Seer = JSON.parse(seerData as string);
  const { colors } = useTheme();
  const { user } = useAuth();
  const { showToast } = useToast();
  const { showInterstitial } = useInterstitial({})
  const { scheduleFortuneCompletionNotification } = useFortuneNotificationManager();
  const [selectedImages, setSelectedImages] = useState<string[]>([]);
  const [selectedImagesBase64, setSelectedImagesBase64] = useState<string[]>([]);
  const [uploadingIndex, setUploadingIndex] = useState<number | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showPhotoModal, setShowPhotoModal] = useState(false);
  const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(null);

  const openImagePicker = (index: number) => {
    setSelectedImageIndex(index);
    setShowPhotoModal(true);
  };

  const handleCloseModal = () => {
    setShowPhotoModal(false);
    setSelectedImageIndex(null);
  };

  const handleCameraPress = () => {
    setShowPhotoModal(false);
    if (selectedImageIndex !== null) {
      takePhoto(selectedImageIndex);
    }
  };

  const handleGalleryPress = () => {
    setShowPhotoModal(false);
    if (selectedImageIndex !== null) {
      pickFromGallery(selectedImageIndex);
    }
  };

  const takePhoto = async (index: number) => {
    try {
      // Request camera permission
      const permission = await ImagePicker.requestCameraPermissionsAsync();
      if (!permission.granted) {
        showToast('Kamera eri≈üim izni gerekli', 'error');
        return;
      }

      const result = await ImagePicker.launchCameraAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 0.8,
        aspect: [4, 3],
        allowsEditing: false,
        base64: true,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        const imageBase64 = result.assets[0].base64 || '';
        
        const newImages = [...selectedImages];
        const newImagesBase64 = [...selectedImagesBase64];
        newImages[index] = imageUri;
        newImagesBase64[index] = imageBase64;
        setSelectedImages(newImages);
        setSelectedImagesBase64(newImagesBase64);
      }
    } catch (error) {
      console.error('Camera error:', error);
      showToast('Kamera ile fotoƒüraf √ßekerken hata olu≈ütu', 'error');
    }
  };

  const pickFromGallery = async (index: number) => {
    try {
      // Request gallery permission
      const permission = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (!permission.granted) {
        showToast('Fotoƒüraf galerisine eri≈üim izni gerekli', 'error');
        return;
      }

      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 0.8,
        aspect: [4, 3],
        allowsEditing: false,
        base64: true,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        const imageBase64 = result.assets[0].base64 || '';
        
        const newImages = [...selectedImages];
        const newImagesBase64 = [...selectedImagesBase64];
        newImages[index] = imageUri;
        newImagesBase64[index] = imageBase64;
        setSelectedImages(newImages);
        setSelectedImagesBase64(newImagesBase64);
      }
    } catch (error) {
      console.error('Gallery picker error:', error);
      showToast('Galeriden fotoƒüraf se√ßerken hata olu≈ütu', 'error');
    }
  };

  const uploadImageToFirebase = async (imageUri: string, index: number): Promise<string> => {
    try {
      setUploadingIndex(index);
      console.log(`üîÑ Starting upload for image ${index + 1}...`);
      console.log(`üì± Image URI: ${imageUri}`);
      console.log(`üë§ User UID: ${user?.uid}`);
      
      const filename = `coffee_fortune_${user?.uid}_${Date.now()}_${index}.jpg`;
      const storageRef = ref(storage, `fortunes/${user?.uid}/${filename}`);
      
      console.log(`üìÇ Storage path: fortunes/${user?.uid}/${filename}`);
      console.log(`üè† Storage bucket: ${storage.app.options.storageBucket}`);

      // Fetch image and convert to blob
      console.log(`üì• Fetching image from URI...`);
      const response = await fetch(imageUri);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const blob = await response.blob();
      console.log(`üìä Blob created - Size: ${blob.size} bytes, Type: ${blob.type}`);
      
      // Check blob size (max 5MB)
      if (blob.size > 5 * 1024 * 1024) {
        throw new Error('Dosya boyutu √ßok b√ºy√ºk (max 5MB)');
      }
      
      // Check if user is authenticated
      if (!user?.uid) {
        throw new Error('Kullanƒ±cƒ± kimlik doƒürulamasƒ± gerekli');
      }
      
      // Upload to Firebase Storage
      console.log(`‚òÅÔ∏è Uploading to Firebase Storage...`);
      const uploadTask = await uploadBytes(storageRef, blob);
      console.log(`‚úÖ Upload completed. Metadata:`, uploadTask.metadata);
      
      // Get download URL
      console.log(`üîó Getting download URL...`);
      const downloadURL = await getDownloadURL(storageRef);
      console.log(`üéâ Image ${index + 1} uploaded successfully: ${downloadURL}`);
      
      return downloadURL;
    } catch (error) {
      console.error(`‚ùå Error uploading image ${index + 1}:`, error);
      
      if (error instanceof Error) {
        console.log(`üîç Error name: ${error.name}`);
        console.log(`üîç Error message: ${error.message}`);
        console.log(`üîç Error stack: ${error.stack}`);
        
        // Check for specific Firebase Storage errors
        if (error.message.includes('storage/unknown')) {
          console.log('üö® Firebase Storage unknown error detected');
          console.log('üîß This usually indicates:');
          console.log('   - Storage rules are too restrictive');
          console.log('   - Storage bucket is not properly configured');
          console.log('   - User authentication issue');
          throw new Error('Firebase Storage yapƒ±landƒ±rma hatasƒ±. L√ºtfen y√∂neticiye ba≈üvurun.');
        } else if (error.message.includes('storage/unauthorized')) {
          throw new Error('Fotoƒüraf y√ºkleme izni yok. L√ºtfen giri≈ü yapƒ±n.');
        } else if (error.message.includes('storage/quota-exceeded')) {
          throw new Error('Depolama alanƒ± dolu. L√ºtfen daha sonra tekrar deneyin.');
        } else if (error.message.includes('storage/unauthenticated')) {
          throw new Error('Kimlik doƒürulamasƒ± gerekli. L√ºtfen tekrar giri≈ü yapƒ±n.');
        } else if (error.message.includes('storage/retry-limit-exceeded')) {
          throw new Error('√áok fazla deneme. L√ºtfen daha sonra tekrar deneyin.');
        } else if (error.message.includes('storage/invalid-format')) {
          throw new Error('Ge√ßersiz dosya formatƒ±. L√ºtfen JPEG veya PNG dosyasƒ± se√ßin.');
        } else if (error.message.includes('storage/object-not-found')) {
          throw new Error('Dosya bulunamadƒ±. L√ºtfen tekrar deneyin.');
        } else if (error.message.includes('storage/project-not-found')) {
          throw new Error('Firebase projesi bulunamadƒ±. L√ºtfen y√∂neticiye ba≈üvurun.');
        } else if (error.message.includes('storage/canceled')) {
          throw new Error('Y√ºkleme iptal edildi.');
        } else if (error.message.includes('HTTP error')) {
          throw new Error('ƒ∞nternet baƒülantƒ±nƒ±zƒ± kontrol edin ve tekrar deneyin.');
        } else {
          throw new Error(`Fotoƒüraf y√ºkleme hatasƒ±: ${error.message}`);
        }
      }
      
      throw new Error('Bilinmeyen bir hata olu≈ütu. L√ºtfen tekrar deneyin.');
    } finally {
      setUploadingIndex(null);
    }
  };

  const submitFortune = async () => {
    if (selectedImages.filter(img => img).length < 4) {
      showToast('L√ºtfen 4 farklƒ± kahve fincanƒ± fotoƒürafƒ± y√ºkleyiniz', 'error');
      return;
    }

    if (!user?.uid) {
      showToast('Kullanƒ±cƒ± giri≈üi gerekli', 'error');
      return;
    }

    setIsSubmitting(true);
    try {
      // Check if user has any pending fortunes
      const userDoc = await getDoc(doc(db, 'users', user.uid));
      if (!userDoc.exists()) {
        throw new Error('Kullanƒ±cƒ± verisi bulunamadƒ±');
      }
      
      const userData = userDoc.data();
      const fortuneRecords = userData.fortunerecord || [];
      
      // Check for pending fortunes
      const pendingFortunes = fortuneRecords.filter((fortune: any) => fortune.status === 'pending');
      if (pendingFortunes.length > 0) {
        showToast('Zaten beklemede olan bir falƒ±nƒ±z var. L√ºtfen √∂nceki falƒ±nƒ±zƒ±n tamamlanmasƒ±nƒ± bekleyiniz.', 'error');
        return;
      }

      // Validate coffee images with AI first
      showToast('G√∂r√ºnt√ºler doƒürulanƒ±yor...', 'info');
      const validBase64Images = selectedImagesBase64.filter(base64 => base64);
      const validation = await validateCoffeeImages(validBase64Images);
      console.log(validation);
      if (!validation.isValid) {
        showToast(`Ge√ßersiz g√∂r√ºnt√º l√ºtfen kahve fincanƒ± fotoƒürafƒ±nƒ±zƒ± kontrol ediniz`, 'error');
        return;
      }
      
      // Get fortune cost
      const fortuneIndex = seer.fortunes.indexOf('Kahve Falƒ±');
      const fortuneCost = seer.coins[fortuneIndex] || seer.coins[0];
      
      const currentCoins = userData.coins || 0;
      
      if (currentCoins < fortuneCost) {
        showToast(`Yetersiz coin! Bu fal i√ßin ${fortuneCost} coin gerekli, mevcut: ${currentCoins}`, 'error');
        return;
      }
      
      // Deduct coins immediately
      await updateDoc(doc(db, 'users', user.uid), {
        coins: currentCoins - fortuneCost
      });
      
      showToast(`${fortuneCost} coin harcandƒ±. Fotoƒüraflar y√ºkleniyor...`, 'info');
      setTimeout(()=> {
        showToast('Fal hazƒ±rlama i≈ülemi biraz zaman alabilir, l√ºtfen bekleyiniz...', 'info');
      }, 5000)

      
      // Upload all images sequentially to show progress
      const downloadUrls: string[] = [];
      for (let i = 0; i < selectedImages.length; i++) {
        if (selectedImages[i]) {
          try {
            const url = await uploadImageToFirebase(selectedImages[i], i);
            downloadUrls.push(url);
          } catch (uploadError) {
            console.error(`Upload error for image ${i + 1}:`, uploadError);
            // Refund coins if upload fails
            await updateDoc(doc(db, 'users', user.uid), {
              coins: currentCoins
            });
            throw uploadError;
          }
        }
      }

      if (downloadUrls.length < 4) {
        // Refund coins if not all images uploaded
        await updateDoc(doc(db, 'users', user.uid), {
          coins: currentCoins
        });
        throw new Error('T√ºm fotoƒüraflar y√ºklenemedi');
      }

      // Generate AI interpretation immediately
      const aiResult = await generateFortuneInterpretation({
        fortuneType: 'Kahve Falƒ±',
        seerData: seer,
        images: selectedImagesBase64,
        userData: userData
      });

      // Create fortune record with AI result but pending status
      const fortuneRecord = {
        id: `${Date.now()}_${Math.random().toString(36).slice(2,9)}_coffee`,
        seerData: seer,
        fortuneType: 'Kahve Falƒ±',
        images: downloadUrls,
        createdAt: new Date(),
        status: 'pending' as const,
        responseTime: seer.responsetime,
        estimatedCompletionTime: new Date(Date.now() + seer.responsetime * 60 * 1000),
        coins: fortuneCost,
        result: aiResult
      };

      // Add to user's document fortunerecord array
      await updateDoc(doc(db, 'users', user.uid), {
        fortunerecord: arrayUnion(fortuneRecord)
      });
      
      // Schedule notification for when fortune is completed
      const notificationId = await scheduleFortuneCompletionNotification({
        seerName: seer.name,
        fortuneType: 'Kahve Falƒ±',
        responseTimeMinutes: seer.responsetime
      });

      if (notificationId) {
        showInterstitial();
      }
      
      showToast('Kahve falƒ±nƒ±z ba≈üarƒ±yla g√∂nderildi!', 'success');
      router.replace('/src/screens/main/navigator/(tabs)/MyFortunes');
      
    } catch (error) {
      console.error('Fortune submission error:', error);
      
      if (error instanceof Error) {
        showToast(error.message, 'error');
      } else {
        showToast('Fal g√∂nderilirken hata olu≈ütu', 'error');
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  // AI interpretation function
  const generateFortuneInterpretation = async ({ fortuneType, seerData, images, userData }: any) => {
    try {
      const { GoogleGenAI, HarmBlockThreshold, HarmCategory } = require('@google/genai');
      const ai = new GoogleGenAI({ apiKey: "AIzaSyDYDevsAsKXs-6P6-qYckbj7YIPCYw9abE" });

      if (!images) {
        console.error('Base64 data is missing for coffee images');
        return;
      }

      const imageData = images.map((image: string) => ({
        inlineData: {
          data: image,
          mimeType: "image/jpeg"
        }
      }));
      

      const prompt = `
üßô‚Äç‚ôÄÔ∏è Sen Kimsin?
Sen bir falcƒ±sƒ±n.
Adƒ±n: ${seerData.name}
Karakterin: "${seerData.character}"
Hakkƒ±nda kƒ±sa bilgi: "${seerData.info}"
Ge√ßmi≈üin, hayat yolculuƒüun: "${seerData.lifestory}"

Bu bilgiler senin yorum stilini ve bakƒ±≈ü a√ßƒ±nƒ± ≈üekillendirir.
Ama kullanƒ±cƒ±ya hi√ßbir zaman bu karakter detaylarƒ±nƒ± a√ßƒ±k√ßa s√∂ylemezsin.
Yalnƒ±zca sezgilerinle hissettirirsin.

‚òï Ne Yapacaksƒ±n?
Kullanƒ±cƒ± "${fortuneType}" yorumunu istiyor.
Sen bu yorumda:

Kahve telvesinden, sembollerden, hislerden yola √ßƒ±karak derin analiz yaparsƒ±n.

G√∂nderilen g√∂rseller: fincanƒ±n i√ßi (telve deseni), diƒüeri tabaƒüƒ±n √ºst√º, diƒüeri fincanƒ±n dƒ±≈ü yanƒ± ve diƒüeri genel g√∂r√ºn√ºm (kapalƒ± fincan + tabak).

Telvede "kader √ßizgileri, deƒüi≈üim sembolleri" gibi i≈üaretler varsa onlarƒ± yorumuna katarsƒ±n.

Kullanƒ±cƒ±nƒ±n ge√ßmi≈üi, hali ve ihtiyacƒ± hakkƒ±nda sezgisel yorumlar yaparsƒ±n.

üë§ Kullanƒ±cƒ± Bilgileri
- Ya≈ü: ${userData?.age || 'bilinmiyor'}
- Bur√ß: ${userData?.sunSign || 'bilinmiyor'}
- Y√ºkselen: ${userData?.ascendantSign || 'bilinmiyor'}
- Cinsiyet: ${userData?.gender || 'bilinmiyor'}
- Q1: ${userData?.prompt?.q1 || 'bilinmiyor'}
- Q2: ${userData?.prompt?.q2 || 'bilinmiyor'}
- Q3: ${userData?.prompt?.q3 || 'bilinmiyor'}
- Q4: ${userData?.prompt?.q4 || 'bilinmiyor'}
- Q5: ${userData?.prompt?.q5 || 'bilinmiyor'}
- Q6: ${userData?.prompt?.q6 || 'bilinmiyor'}
- Q7: ${userData?.prompt?.q7 || 'bilinmiyor'}
- Q8: ${userData?.prompt?.q8 || 'bilinmiyor'}
- Q9: ${userData?.prompt?.q9 || 'bilinmiyor'}
- Q10: ${userData?.prompt?.q10 || 'bilinmiyor'}
- Q11: ${userData?.prompt?.q11 || 'bilinmiyor'}

Bu bilgileri asla doƒürudan s√∂ylemezsin.
Yani ≈üu tarz ifadeler YASAK:

‚ùå "Sen ≈üu bur√ßsun"
‚ùå "≈ûu ya≈ütasƒ±n"
‚ùå "Y√ºkselenin bu"

Onun yerine, bu bilgileri yorumuna dolaylƒ± ≈üekilde, sezgisel bi√ßimde katarsƒ±n.
Yani ≈ü√∂yle olur:
"Hayatƒ±nda bazƒ± ≈üeyleri kontrol etme isteƒüi bazen seni yoruyor olabilir."
"Son d√∂nemde √ßevrende g√∂rd√ºƒü√ºn deƒüi≈üimler, i√ßindeki d√∂n√º≈ü√ºm√º de tetiklemi≈ü gibi."
"Son zamanlarda ya≈üadƒ±ƒüƒ±n belirsizlikler, seni i√ßten i√ße biraz yormu≈ü gibi."
"Kendini ifade etme ihtiyacƒ±n, bazen etrafƒ±ndakilerle olan dengeni zorluyor olabilir."
"Ya≈üadƒ±ƒüƒ±n deneyimler, i√ß d√ºnyanda sessiz ama derin bir deƒüi≈üimi ba≈ülatmƒ±≈ü."
"ƒ∞√ßindeki huzur arayƒ±≈üƒ±, dƒ±≈ü d√ºnyadaki karma≈üayla √ßatƒ±≈üƒ±yor gibi."
"Bazen kendi duygularƒ±nƒ± anlamakta zorlandƒ±ƒüƒ±n anlar seni yava≈ülatƒ±yor olabilir."
"Yakƒ±n √ßevrende g√∂rd√ºƒü√ºn hareketlilik, senin de adƒ±m atmanƒ± cesaretlendiriyor."
"Ge√ßmi≈üte ya≈üadƒ±ƒüƒ±n bazƒ± izler, bug√ºn verdiƒüin kararlarƒ± etkiliyor gibi."
"ƒ∞√ßsel sesin, dƒ±≈üarƒ±daki seslerden daha g√º√ßl√º ve y√∂nlendirici olmaya ba≈ülƒ±yor."
"Bilinmezlikler kar≈üƒ±sƒ±nda hissettiƒüin endi≈üe, seni temkinli adƒ±mlar atmaya zorluyor."
"Kendine y√ºklediƒüin beklentiler, bazen ger√ßek potansiyelini g√∂lgelemi≈ü olabilir."

‚ú® Yanƒ±t Formatƒ± (Zorunlu)
Cevabƒ±nƒ± sadece a≈üaƒüƒ±daki JSON yapƒ±sƒ±yla ver.
Hi√ßbir ekstra a√ßƒ±klama, metin veya yorum yazma.

{
  "interpretation": "Ana yorum burada (200-300 kelime)",
  "advice": "Tavsiyeler burada (50-150 kelime)",
  "timeframe": "Zaman dilimi",
  "warnings": ["Uyarƒ± 1", "Uyarƒ± 2"],
  "positiveAspects": ["Olumlu y√∂n 1", "Olumlu y√∂n 2"]
}
üîê Kritik Kurallar:
Kullanƒ±cƒ± bilgileri doƒürudan s√∂ylenmeyecek ‚ùå

Bilgiler yorumlara sezgisel ve zarif ≈üekilde yedirilecek ‚úÖ

Yorumlar ki≈üisel, doƒüal ve derin olacak ‚úÖ

Dili, falcƒ± karakterine uygun ≈üekilde se√ß (samimi, gizemli, i√ßten) ‚úÖ

Yanƒ±t sadece JSON formatƒ±nda olacak ‚úÖ`;

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: [prompt, ...imageData],
        config: {
          responseMimeType: 'application/json',
          responseSchema: {
            type: 'object',
            required: ["interpretation", "advice", "timeframe"],
            properties: {
              interpretation: { type: 'string' },
              advice: { type: 'string' },
              timeframe: { type: 'string' },
              warnings: { 
                type: 'array',
                items: { type: 'string' }
              },
              positiveAspects: {
                type: 'array',
                items: { type: 'string' }
              }
            },
          },
          safetySettings: [
            {
              category: HarmCategory.HARM_CATEGORY_HARASSMENT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
            {
              category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
            {
              category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
            {
              category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
          ],
        }
      });

      const responseText = response.candidates?.[0]?.content?.parts?.[0]?.text;
      console.log('CoffeeFortune AI Response:', responseText);
      
      if (responseText) {
        try {
          const parsed = JSON.parse(responseText);
          console.log('CoffeeFortune AI Parsed:', parsed);
          return parsed;
        } catch (parseError) {
          console.error('CoffeeFortune JSON parse error:', parseError);
          return null;
        }
      }
      
      return null;
    } catch (error) {
      console.error('AI generation error:', error);
      return null;
    }
  };

  // AI validation function for coffee images
  const validateCoffeeImages = async (images: string[]) => {
    try {
      const { GoogleGenAI, HarmBlockThreshold, HarmCategory } = require('@google/genai');
      const ai = new GoogleGenAI({ apiKey: "AIzaSyDYDevsAsKXs-6P6-qYckbj7YIPCYw9abE" });

      // Use the stored base64 data instead of converting
      //const validBase64Images = selectedImagesBase64.filter(base64 => base64);
      
      if (images.length < 4) {
        console.error('Insufficient base64 data for coffee images');
        return { isValid: false };
      }

      console.log(`ü§ñ Validating ${images.length} coffee images with AI...`);

      const systemInstruction = `
Sen bir kahve falƒ± uzmanƒ±sƒ±n. G√∂r√ºnt√ºleri analiz ederek kahve falƒ± i√ßin uygun olup olmadƒ±ƒüƒ±nƒ± deƒüerlendiriyorsun.

KONTROL KRƒ∞TERLERƒ∞:
- En az bir g√∂rselde ger√ßek bir kahve fincanƒ± yer almalƒ±.
- En az bir g√∂rselde fincan i√ßinde kahve telvesi/tortusu a√ßƒ±k√ßa g√∂r√ºnmeli.
- En az bir g√∂rselde T√ºrk kahvesi fincanƒ± (geni≈ü ve al√ßak tipte) kullanƒ±lmalƒ±.
- En az bir g√∂rselde fincanƒ±n dƒ±≈ü y√ºzeyi g√∂r√ºn√ºr olmalƒ±.
- En az bir g√∂rselde tabak ve kapalƒ± fincan birlikte yer almalƒ±.
- En az bir g√∂rselde fincan net ≈üekilde se√ßilebiliyor olmalƒ± (bulanƒ±k veya karanlƒ±k olmamalƒ±).
- Y√ºklenen t√ºm g√∂rseller kriterlerden en az birini saƒülamalƒ±dƒ±r aksi takdirde ge√ßersiz olarak deƒüerlendir.

GE√áERSƒ∞Z DURUMLAR:
- Kahve fincanƒ± yok
- Telve/tortu yok
- √áay fincanƒ± (k√º√ß√ºk, ince)
- Su bardaƒüƒ±
- Alakasƒ±z objeler
- Y√ºklenen t√ºm g√∂rseller kriterleri saƒülamƒ±yor

√áOK √ñNEMLƒ∞: Yanƒ±tƒ±nƒ± SADECE JSON formatƒ±nda ver:
{
  "isValid": true/false,
}
`;

      const prompt = `
Bu ${images.length} kahve fincanƒ± g√∂r√ºnt√ºs√ºn√º analiz et.
Her g√∂r√ºnt√ºn√ºn kahve falƒ± i√ßin uygun olup olmadƒ±ƒüƒ±nƒ± deƒüerlendir.
Fincan i√ßinde telve/tortu desenleri var mƒ±?
`;

      // Create image data objects
      const imageData = images.map(base64 => ({
        inlineData: {
          data: base64,
          mimeType: "image/jpeg"
        }
      }));

      const response = await ai.models.generateContent({
        model: "gemini-1.5-flash",
        contents: [
          systemInstruction,
          prompt,
          ...imageData
        ],
        config: {
          responseMimeType: 'application/json',
          responseSchema: {
            type: 'object',
            required: ["isValid"],
            properties: {
              isValid: { type: 'boolean' },
            },
          },
          safetySettings: [
            {
              category: HarmCategory.HARM_CATEGORY_HARASSMENT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
            {
              category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
            {
              category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
            {
              category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
              threshold: HarmBlockThreshold.BLOCK_NONE,
            },
          ],
        }
      });

      const responseText = response.candidates?.[0]?.content?.parts?.[0]?.text;
      console.log('‚òï Coffee Validation AI Response:', responseText);
      
      if (responseText) {
        try {
          // Direct JSON parse with structured response
          const parsed = JSON.parse(responseText);
          console.log('‚úÖ Coffee validation result:', parsed);
          
          // Validate response structure
          if (typeof parsed.isValid === 'boolean') {
            return {
              isValid: parsed.isValid,
            };
          } else {
            console.error('‚ùå Invalid response structure:', parsed);
            return { isValid: false };
          }
          
        } catch (parseError) {
          console.error('‚ùå JSON parse failed for coffee validation:', parseError);
          console.log('Raw response:', responseText);
          
          // Fallback: try to extract JSON manually
          try {
            // Remove any non-JSON content
            let cleanResponse = responseText.trim();
            
            // Find JSON object
            const jsonStart = cleanResponse.indexOf('{');
            const jsonEnd = cleanResponse.lastIndexOf('}') + 1;
            
            if (jsonStart !== -1 && jsonEnd !== -1) {
              const jsonString = cleanResponse.substring(jsonStart, jsonEnd);
              console.log('üîß Attempting to parse extracted JSON:', jsonString);
              
              const extracted = JSON.parse(jsonString);
              
              if (typeof extracted.isValid === 'boolean') {
                return {
                  isValid: extracted.isValid,
                };
              }
            }
            
            // If all else fails, try to determine from response text
            const responseTextLower = responseText.toLowerCase();
            if (responseTextLower.includes('ge√ßersiz') || responseTextLower.includes('false') || responseTextLower.includes('invalid')) {
              return { isValid: false };
            } else if (responseTextLower.includes('ge√ßerli') || responseTextLower.includes('true') || responseTextLower.includes('valid')) {
              return { isValid: true };
            }
            
          } catch (fallbackError) {
            console.error('‚ùå Fallback parse also failed:', fallbackError);
          }
          
          return { isValid: false };
        }
      }
      
      return { isValid: false };
    } catch (error) {
      console.error('‚ùå Coffee validation error:', error);
      return { isValid: false };
    }
  };

  const renderImageSlot = (index: number) => (
    <Animated.View 
      key={index}
      style={[styles.imageSlot, { borderColor: colors.border }]}
      entering={SlideInRight.delay(index * 100).springify()}
    >
      <TouchableOpacity
        style={[styles.imageButton, { backgroundColor: selectedImages[index] ? 'transparent' : colors.background }]}
        onPress={() => openImagePicker(index)}
        disabled={uploadingIndex === index || isSubmitting}
      >
        {selectedImages[index] ? (
          <Image 
            source={{ uri: selectedImages[index] }}
            style={styles.selectedImage}
            contentFit="cover"
          />
        ) : (
          <View style={styles.placeholderContent}>
            <Icon name="cafe-outline" size={40} color={colors.secondary} />
            <Text style={[styles.placeholderText, { color: colors.secondaryText }]}>
              {index + 1}. Fotoƒüraf
            </Text>
          </View>
        )}
        {uploadingIndex === index && (
          <View style={styles.loadingOverlay}>
            <Text style={[styles.loadingText, { color: colors.text }]}>
              Y√ºkleniyor...
            </Text>
          </View>
        )}
      </TouchableOpacity>
    </Animated.View>
  );

  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Seer Info */}
        <Animated.View 
          style={[styles.seerInfo, { backgroundColor: colors.secondaryText }]}
          entering={FadeInDown.duration(800).springify()}
        >
          <Image
            source={{ uri: seer.url }}
            style={[styles.seerImage, { borderColor: colors.primary }]}
            contentFit="cover"
          />
          <View style={styles.seerDetails}>
            <Text style={[styles.seerName, { color: colors.background }]}>
              {seer.name}
            </Text>
            <Text style={[styles.fortuneType, { color: colors.background }]}>
              ‚òï Kahve Falƒ±
            </Text>
            <Text style={[styles.responseTime, { color: colors.background }]}>
              ‚è±Ô∏è {seer.responsetime} dakika i√ßinde yanƒ±t
            </Text>
          </View>
        </Animated.View>

        {/* Instructions */}
        <Animated.View 
          style={styles.instructions}
          entering={FadeIn.delay(300).springify()}
        >
          <Text style={[styles.instructionTitle, { color: colors.primary }]}>
            üìã Kahve Falƒ± Talimatlarƒ±
          </Text>
          <Text style={[styles.instructionText, { color: colors.text }]}>
            L√ºtfen a≈üaƒüƒ±daki 4 farklƒ± kahve fincanƒ±nƒ±n fotoƒüraflarƒ±nƒ± √ßekin:
          </Text>
          <View style={styles.instructionList}>
            <Text style={[styles.instructionItem, { color: colors.secondaryText }]}>
              ‚Ä¢ 1Ô∏è‚É£ Genel g√∂r√ºn√ºm (Kapalƒ± fincan + tabak)
            </Text>
            <Text style={[styles.instructionItem, { color: colors.secondaryText }]}>
              ‚Ä¢ 2Ô∏è‚É£ Fincanƒ±n i√ßi (telve deseni)
            </Text>
            <Text style={[styles.instructionItem, { color: colors.secondaryText }]}>
              ‚Ä¢ 3Ô∏è‚É£ Tabaƒüƒ±n √ºst√º
            </Text>
            <Text style={[styles.instructionItem, { color: colors.secondaryText }]}>
              ‚Ä¢ 4Ô∏è‚É£ Fincanƒ±n dƒ±≈ü yanƒ±
            </Text>
          </View>
        </Animated.View>

        {/* Image Upload Section */}
        <Animated.View 
          style={styles.uploadSection}
          entering={FadeIn.delay(500).springify()}
        >
          <Text style={[styles.uploadTitle, { color: colors.primary }]}>
            üì∑ Fotoƒüraf Y√ºkleme
          </Text>
          <View style={styles.imageGrid}>
            {[0, 1, 2, 3].map(renderImageSlot)}
          </View>
        </Animated.View>

        {/* Submit Button */}
        <Animated.View 
          style={styles.submitSection}
          entering={FadeIn.delay(700).springify()}
        >
          <CustomButton
            title={isSubmitting ? "G√∂nderiliyor..." : "üîÆ Kahve Falƒ±nƒ± G√∂nder"}
            onPress={submitFortune}
            disabled={isSubmitting || selectedImages.filter(img => img).length < 4}
            variant="primary"
            contentStyle={[
              styles.submitButton,
              { 
                opacity: (selectedImages.filter(img => img).length < 4 || isSubmitting) ? 0.5 : 1,
                backgroundColor: colors.primary,
                width: '80%'
              }
            ]}
          />
        </Animated.View>
      </ScrollView>

      {/* Photo Picker Modal */}
      <PhotoPickerModal
        visible={showPhotoModal}
        onClose={handleCloseModal}
        title="Fotoƒüraf Se√ß"
        subtitle={selectedImageIndex !== null ? `${selectedImageIndex + 1}. fincan fotoƒürafƒ±nƒ± nereden se√ßmek istiyorsunuz?` : ''}
        onCamera={handleCameraPress}
        onGallery={handleGalleryPress}
      />
    </View>
  );
};

export default CoffeeFortune; 